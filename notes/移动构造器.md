## 移动构造器

- `Person &operator=(Person &&other)` 中的 & 表示返回引用类型，而不是指针。这样做的好处是避免不必要的拷贝、支持链式赋值以及性能更高
- `return *this;` 中的 `this` 是一个指向当前对象的指针，它在每个非静态成员函数中都隐式存在
- `*this` 是对 `this` 指针的解引用，结果是当前对象本身
- 对于基本数据类型（包括基本整数类型、浮点数、字符、布尔值、原始指针等），编译器会在编译时建立符号表，将变量名映射到内存位置，代码生成时将变量名替换为具体的内存访问指令，运行时 CPU 执行这些内存访问指令。关键点是**变量名在编译完成后就消失了**，运行时只有内存地址的直接访问。编译器通过符号表在编译期间完成了这个"翻译"工作
- 基本数据类型没有“移动”的概念，因为它们没有移动构造函数或者移动赋值运算符， `std::move` 只是将其转换为右值引用，最终还是调用普通的赋值操作。如下面两行代码：

```c++
b = a;              // 直接赋值
b = std::move(a);   // “移动”赋值
```

编译器可能会将其优化为相同的指令序列，底层还是一样的内存复制操作

- **核心原则**：只对资源管理复杂、复制成本高的对象（包括字符串、容器、智能指针和自定义类对象）使用移动语义，对基本数据类型直接复制即可

- `= delete` 明确告诉编译器——不要生成这些函数，这是一种主动禁用某些操作的方式
- 当 `= delete` 用于禁止拷贝构造函数和拷贝复制操作符时，设计意图是强制使用移动语义，避免昂贵的深拷贝操作，确保资源只能被移动而不能被复制

