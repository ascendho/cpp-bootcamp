## 向量

- `inline` 关键字的主要作用是建议编译器进行内联优化，即在调用点直接展开函数代码，而不是进行函数调用，避免了函数调用开销（消除压栈、跳转、返回等操作），它还允许在头文件中定义函数——解决多重定义问题
- `inline` 适用于一些需要频繁调用简短函数的软件或者系统对性能敏感的场景中
- 函数的 `const` 关键字承诺不修改对象状态，且编译器会验证函数是否的确没有修改成员
- `const` 对象只能调用 `const` 成员函数
- 分析下面这段代码：

```c++
void print_int_vector(const std::vector<int> &vec) {
  for (const int &elem : vec) {
    std::cout << elem << " ";
  }
  std::cout << "\n";
}
```

1. 函数参数中采用传引用而不是传值的原因：如果这个向量的容量很大，复制的成本将会很高
2. 循环中采用的引用在此处对性能优化不大，因为 `int` 只有4字节，复制成本很低，现代编译器通常会优化掉这种差异；但若 `vec` 是 `string` 类型的向量，则对性能有一定的提升
3. 循环中 `const` 关键字确保函数不会意外修改原始 `vec` 元素的值

- `push_back` 是将一个已构造的对象复制或移动到容器末尾，参数支持对象的拷贝或右值引用，适合已有对象需要移动或者需要保留原对象拷贝的场景
- `emplace_back` 是直接在容器末尾就地构造对象，参数支持构造函数，适合复杂构造对象或者对性能敏感的场景
- `Lambda` 表达式是现代 C++ 的重要特性，它允许我们在代码中定义匿名函数（无名函数），如下面这段程序：

```c++
 point_vector.erase(
      std::remove_if(point_vector.begin(), point_vector.end(),
                     [](const Point &point) { return point.GetX() == 37; }),
      point_vector.end());
```

其中 `[]` 表示捕获列表，空列表表示不捕获外部变量； `(const Point &point)` 为参数列表，接受一个 `const Point` 引用，`{ return point.GetX() == 37; }` 为函数体，返回bool值

- `remove_if` 的工作机制是扫描元素并将不满足条件的元素移动到前面，满足条件的元素移动到后面，返回分界迭代器 `new_end` （指向“新的逻辑末尾”）
- `erase` 的作用是删除 `new_end` 到 `end` 间到所有元素
- `erase-remove` 相比朴素的删除方式更高效，因为它减少了元素的移动次数
- C++ 20 直接提供了 `std::erase_if` 来简化上述操作