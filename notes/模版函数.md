## 模版函数

- `template <>` 表示模版特化，为特定类型提供专门的实现。如：

```c++
template <typename T> void print_msg() { std::cout << "Hello world!\n"; }

// Specialized templated function, specialized on the float type.
template <> void print_msg<float>() {
  std::cout << "print_msg called with float type!\n";
}
```

特化版本会覆盖通用版本，常用于需要对某些类型进行特殊处理的场景

- 针对非类型模版参数，如：

```c++
// Lastly, template parameters do not have to be classes. Take this basic (yet
// very contrived) function that takes in a bool as a template parameter and
// does different things to the argument depending on the boolean argument.
template <bool T> int add3(int a) {
  if (T) {
    return a + 3;
  }

  return a;
}
```

这样设计的好处主要在于：

1. 编译时即进行计算和优化，避免运行时计算
2. 类型系统保证常量正确性，避免魔数

核心的编程思想在于：**将运行时的决策转移到编译时**，从而获得更好的性能。这在系统级编程（如数据库、操作系统、游戏引擎等这些极其重视性能的领域）中特别重要

- 在现代 `C++` 中推荐使用 `constexpr if` 来实现类似功能，语法和意图都更清晰、明确

